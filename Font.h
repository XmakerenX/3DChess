#ifndef  _FONT_H
#define  _FONT_H

#include <iostream>
#include <utility>
#include <map>
#include <fstream>
#include <GL/glew.h>
#include <glm/glm.hpp>
#include <ft2build.h>
#include FT_FREETYPE_H
#include <cmath>
#include <string>
#include "RenderTypes.h"
#include "Shader.h"
#include "monoBuffer.h"
#include "Sprite.h"

struct FontInfo
{
    FontInfo()
    {
        fontName = "";
        fontSize = 0;
    }

    FontInfo(const FontInfo& toCopy)
    {
        fontName = toCopy.fontName;
        fontSize = toCopy.fontSize;
    }

    FontInfo(std::string fontName, int fontSize)
    {
        this->fontName = fontName;
        this->fontSize = fontSize;
    }

    std::string fontName;
    int fontSize;
};

// Holds all state information relevant to a character glyph as loaded using FreeType
struct CharGlyph {
    GLuint     TextureID;
    glm::ivec2 Size;
    glm::ivec2 Bearing;     // Offset from baseline to left/top of glyph
    long       Advance;     // Horizontal offset to advance to next glyph
};

struct CharGlyphAtlas
{
    Rect textureRect;
    glm::ivec2 Size;
    glm::ivec2 Bearing;     // Offset from baseline to left/top of glyph
    long       Advance;     // Horizontal offset to advance to next glyph
};

// stores glpyh buffer data and info, ready to be batched to a single texture
class CharGlyphBat : public monoBuffer
{
public:
    // default constructor
    CharGlyphBat() : monoBuffer()
    {
        Bearing_ = {0,0};
        Advance_ = 0;
    }

    // copy constructor
    CharGlyphBat(const CharGlyphBat& c) : monoBuffer(c.getBuffer(),c.width_,c.height_)
    {
        Bearing_ = c.Bearing_;
        Advance_ = c.Advance_;
    }

    // move constructor
    CharGlyphBat(CharGlyphBat&& c)
    {
        buffer_ = c.getBuffer();
        width_ = c.width_;
        height_ = c.height_;
        empty = false;

        Bearing_ = c.Bearing_;
        Advance_ = c.Advance_;

        c.buffer_ = nullptr;
        c.width_ = 0;
        c.height_ = 0;
        c.empty = true;

        c.Bearing_ = glm::ivec2(0,0);
        c.Advance_ = 0;
    }

    // constructor
    CharGlyphBat(glm::ivec2 bearing, long advnace)
    {
        Bearing_ = bearing;
        Advance_ = advnace;
    }

    ~CharGlyphBat()
    {
        ;
    }

    glm::ivec2 Bearing_;     // Offset from baseline to left/top of glyph
    long       Advance_;     // Horizontal offset to advance to next glyph
};

struct FontString {
    GLuint texID;
    GLuint width;
    GLuint height;
};

class mkFont
{
public:
    enum class TextFormat{Left, Center, HorizCenter, VerticalCenter, Right, RightVerticalCenter};

    mkFont();
    mkFont(std::string fontName, bool isPath = false);
    mkFont(const mkFont&  toCopy);
    mkFont(mkFont&& toMove);
    ~mkFont();

    int init(int m_fontSize, int height, int hDpi, int vDpi);
    void renderText(Shader *shader, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color);
    Point calcTextRect(std::string text);
    Point clipTextToRect(const Rect& rc, std::string& textInRect, int maxTextHeight);
    void renderTextAtlas(Sprite &sprite, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec4 color);
    void renderToRect(Sprite& sprite, std::string text, Rect rc, glm::vec4 color, TextFormat format = TextFormat::Left, bool clipText = true);
    void renderTextBatched(Shader *shader, std::string text, GLfloat x, GLfloat y, GLfloat scale, glm::vec3 color);
    GLuint renderFontAtlas(Sprite& sprite, const Rect &rc);
    static std::string getFontPath(std::string fontName);
    static std::string getFontNameFromPath(std::string path);

    GLuint getFontSize();
    void setScreenHeight(int height);

    static void printallFonts();

private:
    bool cacheTextTexutre(std::string text);
    void cacheGlyth(FT_Library ft, FT_Face face);
    void cacheGlythBatched(FT_Library ft, FT_Face face, int maxHeight, int maxOffset);
    void createFontAtlas(FT_Library ft, FT_Face face);

    std::string fontPath;
    std::map<GLchar, CharGlyph> charGlyphs;
    std::map<GLchar, CharGlyphAtlas> charGlyphsAtlas;
    std::map<GLchar, CharGlyphBat> charGlyphsBat;
    std::map<std::string, FontString> stringTextures;
    GLuint VAO;
    GLuint VBO;
    VertexIndex indices[6];

    //TODO: renderTextBatched still needs to know screen height might remove this function all together
    //      as it is broken right now.
    int m_height;

    int m_maxHeight;
    int m_maxOffset;

    GLuint m_maxWidth;
    GLuint m_maxRows;
    GLuint m_avgWidth;

    GLuint m_textureAtlas;
    GLuint m_fontSize;

    // values that are generated by calcTextRect and are being cached as to not recalculate them
    std::string m_cachedText;
    Point m_cachedTextSize;
    int m_cachedMaxBearing;
};

#endif  //_FONT_H
